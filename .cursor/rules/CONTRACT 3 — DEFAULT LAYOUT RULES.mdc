CONTRACT 3 — DEFAULT LAYOUT RULES
Дефолтные правила вёрстки при отсутствии конкретных указаний в макете, референсе или промте

1. Единая визуальная сущность

Если элемент (панель фильтров, навигация, side-menu) реализован для мобильной версии, он должен 1:1 использоваться в десктопе. Запрещено создавать отдельную визуальную реализацию для desktop, дублируя mobile-версию. Один компонент, одна логика, одна разметка.

2. Sticky sidebar protocol

Панели фильтров, навигации, боковые меню:

- Сворачивание/разворачивание через единую кнопку-toggle (mobile)
- Кнопка-toggle остаётся видимой в свёрнутом состоянии
- По умолчанию: панель **не имеет** внутреннего скролла — растягивается на весь контент, скроллится страница
- Внутренний `overflow-y: auto` допустим **только** при явном указании в макете/промте; скроллбары в этом случае скрыты (`scrollbar-width: none`)
- `position: sticky` допустимо только если панель гарантированно помещается в viewport (короткие навбары, toolbars). Для длинных панелей (фильтры) — sticky не применяется, панель идёт в потоке

3. Ритмическая симметрия

Все элементы управления внутри одного логического блока (колонка фильтров, форма, toolbar) должны иметь:

- одинаковую ширину (через `fullWidth` или grid)
- одинаковую высоту trigger-строки (через matching `min-height` / padding tokens)
- одинаковые горизонтальные padding
- одинаковый `border-radius`

Это обеспечивается на уровне компонентной базы: Accordion SIZE_CLASSES используют те же токены, что и Dropdown SIZE_CLASSES (`--space-button-x-*`, `--space-button-y-*`, `--space-28/36/40`, `--space-button-gap-*`, `--radius-default`). Любой контрол одного size автоматически имеет одинаковую геометрию trigger-строки.

4. Шеврон / иконка действия

Всегда прижата к правому краю через `ml-auto` или `justify-between`. Никогда не «плавает» в потоке контента. Если между label и шевроном есть промежуточный контент (chips, badge), он занимает `flex-1 min-w-0` и обрезается по overflow.

5. Gap-консистентность

Одинаковый gap-токен внутри одного логического блока. Запрещено иметь разный gap для mobile и desktop при идентичном контенте. Единственное допустимое исключение — изменение количества колонок в grid.

6. Паттерн множественного выбора

Стандартный протокол для фильтров с множественным выбором:

- Раскрывающийся блок (accordion-like trigger)
- Внутри: чекбоксы с label
- В заголовке (trigger): выбранные значения отображаются как Chip (с кнопкой удаления)
- При overflow (не помещаются все Chip): Badge с числом оставшихся (`+N`)
- Шеврон прижат к правому краю

6.1. Dynamic Chip Overflow в триггере мультиселект-контролов

Чипсы в триггере Dropdown/Autocomplete с `multiple` занимают **всю доступную ширину** контрола, а не фиксированное количество. Статичный `maxVisibleChips` запрещён — количество видимых чипсов определяется динамически через `useOverflowCounter`:

- Чипсы рендерятся в `overflow-hidden` flex-контейнере (`flex-1 min-w-0`)
- Badge `+N` — сиблинг контейнера (вне overflow), отображается только если есть полностью скрытые чипсы
- Если все чипсы помещаются — Badge не показывается
- Если последний видимый чипс не помещается целиком — применяется gradient fade через CSS `mask-image: linear-gradient(to right, black calc(100% - 24px), transparent)`
- При увеличении ширины контрола умещается больше чипсов, Badge уменьшается/исчезает
- При максимальном заполнении Badge находится рядом с иконкой очистки с соблюдением gap

Layout в коде:
```
<wrapper flex-1 min-w-0 flex gap-1>
  <chips-container ref={chipsRef} flex-1 min-w-0 overflow-hidden [mask-image если gradient]>
    {selected.slice(0, renderCount).map(chip)}
  </chips-container>
  {overflowCount > 0 && <Badge>+{overflowCount}</Badge>}
</wrapper>
```

7. Числовые диапазоны

Два числовых инпута всегда в `grid grid-cols-2` с gap. Суммарная ширина пары = ширина одного полноразмерного инпута в том же блоке. Оба инпута одного размера.

8. Не дублировать визуальные сущности

Если один и тот же набор контролов нужен в двух местах (mobile-panel и desktop-sidebar), используется один компонент-обёртка с адаптивным поведением. Запрещено создавать два раздельных блока разметки с идентичным контентом.

9. Адаптивный layout

- Mobile: элементы занимают полную ширину, фильтры коллапсируемые
- Desktop: элементы сохраняют ту же визуальную структуру, могут быть размещены в sidebar
- Переход между mobile и desktop: только изменение расположения (flex-direction, grid-cols), но не структуры или стилей самих компонентов

11. Frame parity — паритет мобильного и десктопного фрейма

Если UI-блок (фильтр-панель, side-menu, навигация) корректно отображается на мобильном экране, то на десктопе он выводится как **тот же самый фрейм мобильной ширины**. Запрещено:

- Назначать десктопному sidebar ширину, отличную от ширины мобильного фрейма
- Добавлять внутренний скролл (`overflow-y: auto`, `max-height`) — панель растягивается на весь свой контент, скроллится страница целиком
- Скрывать контент, который виден в мобильной версии

Правило ширины:

- Мобильная панель: `w-full` (занимает всю ширину экрана)
- Десктопный sidebar: фиксированная ширина, равная ширине мобильного фрейма (стандарт: `358px` — ширина контента iPhone 390px минус `px-[var(--space-16)]`)
- Минимальная поддерживаемая ширина контента: 300px

Внутри фрейма — один и тот же компонент (`FilterContent`, `NavContent` и т.д.) без каких-либо стилевых различий между mobile и desktop. Различается только способ размещения фрейма:

| Breakpoint | Размещение | Поведение |
|---|---|---|
| < tablet | `w-full`, collapsible toggle | Кнопка toggle показывает/скрывает панель |
| ≥ tablet | `w-[358px] shrink-0`, aside | Всегда видна как sidebar слева от контента |

Никогда не хардкодить произвольную ширину sidebar (320px, 280px, 250px). Ширина определяется из формулы: `target mobile viewport - 2 × horizontal page padding`.

10. Z-index protocol

- Header/Navigation: `z-[var(--z-modal)]`
- Filter panel (sticky): `z-[var(--z-popover)]`
- Dropdowns/Popovers: `z-[var(--z-popover)]`
- Modals: `z-[var(--z-modal)]`
- Tooltips: `z-[var(--z-tooltip)]`

11. Вертикальное выравнивание элементов в строке

Везде, где строковое значение (label, текст опции) находится рядом с иконкой, чекбоксом, бэйджем, чипсом или другим нетекстовым элементом, **все дочерние элементы обязаны быть выровнены вертикально по центру** через `flex items-center` на общем контейнере-строке.

Правила:

- Контейнер-строка (option row, trigger, list item): `flex items-center`
- Обёртки вокруг вложенных элементов (Checkbox, Badge, IconSlot, RadioButton) внутри строки обязаны быть `flex items-center` или `inline-flex items-center`, а не plain `<span>` / `<div>` без flex — plain элементы наследуют line-height и создают вертикальное смещение
- Компоненты-атомы (Checkbox, RadioButton, Chip, Badge) внутри себя уже используют `inline-flex items-center`, но их обёртки в потребляющих компонентах тоже обязаны иметь flex-выравнивание

Запрещено: `<div className="shrink-0">{checkbox}</div>` — нет flex, высота зависит от line-height.
Правильно: `<div className="shrink-0 flex items-center">{checkbox}</div>`.

12. Поведение контролов — focus, clear, hover, spinners

12.1. Focus rings и активные бордеры

Толщина focus-кольца и активного бордера на любом контроле (Input, Dropdown, Accordion, Autocomplete) **не более 1px**. Запрещено визуальное суммирование: когда контрол в раскрытом состоянии (`isOpen`) и variant rules уже применяют `border-[var(--color-brand-primary)]`, focus ring (`shadow-focus-brand`) не применяется. Контрол в открытом (active) состоянии уже имеет 1px branded border; добавление focus shadow создаёт визуальный эффект 2px, что запрещено.

Правило в коде: `!disabled && !isOpen && focusRing` — в Dropdown, Accordion, Autocomplete.

12.2. Кнопка очистки (Clear / ×) в контролах

Кнопка очистки (ClearButton) в Dropdown и других select-like контролах **не отображается**, если выбрано пустое или дефолтное значение (`value === ''`). Крестик при дефолтном значении вводит пользователя в заблуждение, т.к. клик ничего не меняет.

Правило в коде: `const hasMeaningfulSelection = selected.length > 0 && selected.some(v => v !== '');` — используется вместо `hasSelection` для `clearVisible`.

12.3. Hover-эффект на Chip внутри контролов

Любой `Chip`, используемый внутри интерактивного контрола (Dropdown multi-select, TagInput и т.д.) или как самостоятельный интерактивный элемент, **обязан иметь hover-эффект**. Стандартный паттерн: `hover:brightness-95 active:brightness-90` — работает универсально с любым фоном из contract rules, адаптируется к теме.

12.4. Числовые инпуты — spinner buttons

Для `type="number"` инпутов нативные browser spinners **скрываются** (`[appearance:textfield]`, `::-webkit-inner-spin-button`). Вместо них рендерятся кастомные кнопки increment/decrement:

- Прилипают к правому краю контрола без зазоров (отрицательные margins, равные padding контрола)
- Заполняют полную высоту контрола, разделяя её пополам (верхняя — вверх, нижняя — вниз)
- Имеют тематизированные цвета: `bg-[var(--color-surface-1)]`, `hover:bg-[var(--color-surface-2)]`, `text-[var(--color-text-muted)]`
- Разделены горизонтальной и вертикальной линиями через `border`
- Наследуют `border-radius` от родительского контрола через `rounded-tr-[inherit]` / `rounded-br-[inherit]`
- **Появляются только при наведении мыши на инпут или фокусе**: `opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 transition-opacity`

12.5. Шеврон (правая иконка) в раскрывающихся контролах

При открытии Dropdown (и аналогичных контролов с popover):

- Шеврон выполняет **flip** (rotate-180°) через `transition-transform duration-200`
- Шеврон окрашивается в **primary цвет**: `text-[var(--color-brand-primary)]` при `isOpen === true`

Это обеспечивает визуальную обратную связь о состоянии контрола. Поведение аналогично `Accordion` — при раскрытии иконка меняет цвет и ориентацию.

12.6. Hover в выпадающих списках — dark theme совместимость

Для option items внутри Popover запрещено использовать `--color-brand-hover-bg` для ховеров, т.к. в тёмной теме это значение (`#1A2330`) совпадает с фоном popover (`--color-surface-1: #1A2330`). Вместо этого используется `hover:bg-[var(--color-surface-3)]` — гарантированный контраст в обеих темах.

12.7. Фильтры с множественным выбором

Предпочтительная реализация фильтров с множественным выбором — `Dropdown` с `multiple` пропом вместо `Accordion` с чекбоксами. Dropdown `multiple` предоставляет:

- Встроенные чекбоксы в popover
- Chips выбранных значений в trigger
- Badge с overflow counter (+N)
- Кнопку очистки через `showClearButton`
- Единый паттерн взаимодействия с остальными Dropdown в интерфейсе

12.8. Чекбоксы в мультиселект-опциях — использование компонента Checkbox

Индикаторы выбора в `Dropdown` с `multiple` **обязаны** использовать компонент `Checkbox` из компонентной базы (`primitives/Checkbox`), а не инлайновую разметку. Инлайновые `<span>` с бордером без фонового заполнения выглядят как точки и не читаются как чекбоксы.

Правила:

- Размер чекбокса: `md` (20×20px) — стандартный размер компонента Checkbox, обеспечивает чёткую визуальную идентификацию
- Чекбокс оборачивается в `<span className="pointer-events-none shrink-0">` — клик обрабатывается родительским option-элементом, а не самим Checkbox
- Gap между чекбоксом и текстом опции: `gap-[var(--space-20)]` (20px) — увеличенный отступ для читаемости. В самом компоненте Checkbox gap между индикатором и label тоже `--space-20`
- Для single-select (без `multiple`) gap остаётся `gap-2`

Запрещено: использовать кастомные inline-индикаторы (`<span className="w-4 h-4 border ...">`) вместо компонента Checkbox.

12.9. Тристейт чекбокс и режим «кроме» (exclude)

Чекбокс поддерживает три визуальных режима кроме unchecked:

- **checked** — галочка (✓). Значение включено в выборку
- **indeterminate** — плюс (+). Частичный выбор (например, когда выбраны не все дочерние элементы). Пропс: `indeterminate={true}`
- **exclude** — минус (−). Значение исключено из выборки (режим «кроме»). Пропс: `exclude={true}`

Цикл тристейта при `allowExclude` в Dropdown/Autocomplete: unchecked → checked → **exclude** → unchecked.

Визуальные правила для exclude:
- Индикатор: синий фон + белый минус (−) — тот же фон что у checked/indeterminate
- Label рядом с чекбоксом: `line-through` + `text-[var(--color-text-muted)]`
- Chip в trigger: `state="exclude"` — dashed border, `opacity-60`, текст зачёркнут, префикс «−»
- Chip в popover (область выбранных): отдельная группа после selected-чипсов, со стилем `state="exclude"`

API Dropdown/Autocomplete:
- `allowExclude?: boolean` — включает тристейт-цикл (по умолчанию false)
- `excludedValues?: string[]` — контролируемый массив исключённых значений
- `defaultExcludedValues?: string[]` — начальные excluded для uncontrolled режима
- `onExcludedChange?: (excluded: string[]) => void` — колбек при изменении excluded

Разделение selected/excluded на уровне API обеспечивает обратную совместимость — без `allowExclude` поведение не меняется.

13. Container-bound controls

Любой интерактивный контрол (Input, Dropdown, Accordion, Autocomplete, Button) размещённый внутри ограниченного контейнера (`grid` с явным числом колонок, `flex` с фиксированной шириной) **обязан сжиматься ниже своего intrinsic `min-width`**.

Правила:

- `fullWidth` проп на каждом контрол-компоненте обязан применять `w-full !min-w-0 !max-w-none` (а не просто `w-full`), чтобы компонент всегда подчинялся размерам родительского контейнера
- Для составных компонентов (Dropdown, Autocomplete), где bordered-элемент (trigger) находится внутри обёртки, `!max-w-none` и `!min-w-0` обязаны применяться **к trigger-элементу**, а не только к обёртке. Дополнительно, на trigger при `fullWidth` ставится inline `style={{ maxWidth: 'none', minWidth: 0 }}` как гарантия переопределения variant rules из contract JSON
- `min-w-[...]` и `max-w-[...]` токены из variant rules (contract JSON) и `SIZE_CLASSES` существуют только как **standalone fallback** для компонентов вне ограниченных контейнеров; они никогда не должны переопределять явное ограничение родителя
- Передача `className="min-w-0"` снаружи **ненадёжна** (Tailwind мержит классы по порядку вставки в CSS-бандл, а не по позиции в строке `className`). Исправление должно быть внутри компонента: при `fullWidth === true` компонент сам эмитирует `!min-w-0 !max-w-none`
- Запрещено использовать внешние хаки (`className="min-w-0"`, `style={{ minWidth: 0 }}`) для компенсации внутреннего `min-w` / `max-w` компонента — это признак бага в компонентной базе
